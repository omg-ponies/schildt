<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Schildt</title>
  <link id="dynamic-favicon" rel="icon" type="image/svg+xml" href="" />
  <style>
    :root { --fade-ms: 600; --fw-count: 70; }
    * { box-sizing: border-box; }
    html, body {
      height: 100%;
      margin: 0;
      background: #000;
    }
    /* Two-layer crossfade background */
    .stage {
      position: fixed;
      inset: 0;
      overflow: hidden;
      background: #000;
    }
    .bg {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: cover;
      opacity: 0;
      transition: opacity var(--fade-ms)ms ease-in-out;
      will-change: opacity, transform;
    }
    .bg.active { opacity: 1; }

    /* Fireworks */
    .particle {
      position: fixed;
      width: 2px;
      height: 2px;
      border-radius: 50%;
      pointer-events: none;
      will-change: transform, opacity;
    }

    /* Motion preference */
    @media (prefers-reduced-motion: reduce) {
      .bg { transition: none; }
    }
  </style>
</head>
<body>
  <div class="stage" aria-hidden="true">
    <img id="bgA" class="bg active" alt="" />
    <img id="bgB" class="bg" alt="" />
  </div>

  <script>
    // ----------------- Config -----------------
    const THEMES = {
      0: { theme: "clouds",   emoji: "â˜ï¸" },
      1: { theme: "space",    emoji: "ðŸš€" },
      2: { theme: "crocodile",emoji: "ðŸŠ" },
      3: { theme: "hamsters", emoji: "ðŸ¹" },
      4: { theme: "batman",   emoji: "ðŸ¦‡" },
      5: { theme: "applause", emoji: "ðŸ‘" },
      6: { theme: "trippy",   emoji: "ðŸŒˆ" }
    };

    // Exposing a raw API key in client code means anyone can use it.
    // In production, proxy this request server-side and keep the key secret.
    const GIPHY_KEY = "7i7EMSlq48BdYNGdZE85wYLyoGf6M4Nz";
    const DAY = new Date().getDay();
    const { theme, emoji } = THEMES[DAY] || THEMES[0];

    const PRELOAD_COUNT = 5;      // initial burst
    const CACHE_MAX = 20;         // cap memory/network use
    const SWAP_MS = 6000;         // rotation interval
    const FETCH_TIMEOUT_MS = 8000;

    const cache = [];
    let idx = -1;
    let timer = null;
    let activeId = "bgA";

    const elA = document.getElementById("bgA");
    const elB = document.getElementById("bgB");

    // --------------- Utils -------------------
    const sleep = (ms) => new Promise(r => setTimeout(r, ms));
    function withTimeout(promise, ms) {
      const controller = new AbortController();
      const t = setTimeout(() => controller.abort(), ms);
      return Promise.race([
        promise(controller.signal),
        (async () => { await sleep(ms + 1); throw new Error("timeout"); })()
      ]).finally(() => clearTimeout(t));
    }

    function setFavicon(emojiChar) {
      const link = document.getElementById("dynamic-favicon");
      const svg = `
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 128 128">
          <rect width="128" height="128" rx="24" fill="black"/>
          <text x="50%" y="64%" text-anchor="middle" font-size="100">${emojiChar}</text>
        </svg>`;
      link.href = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svg);
    }

    function setFallbackSolid() {
      // Slight vignette-ish feel using a tiny SVG (keeps it light)
      const svg = `
        <svg xmlns="http://www.w3.org/2000/svg" width="8" height="8">
          <rect width="8" height="8" fill="#000"/>
        </svg>`;
      const url = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(svg);
      elA.src = url;
      elB.src = url;
    }

    // --------------- GIPHY -------------------
    async function fetchRandomGifUrl(tag) {
      const url = new URL("https://api.giphy.com/v1/gifs/random");
      url.searchParams.set("api_key", GIPHY_KEY);
      url.searchParams.set("tag", tag);

      const fetcher = (signal) => fetch(url.toString(), { signal }).then(r => {
        if (!r.ok) throw new Error("HTTP " + r.status);
        return r.json();
      });

      const data = await withTimeout(fetcher, FETCH_TIMEOUT_MS);
      const gif = data?.data?.images?.original?.url;
      if (!gif) throw new Error("Invalid GIPHY response");
      return gif;
    }

    async function preloadInitial(tag) {
      const tasks = Array.from({ length: PRELOAD_COUNT }, () =>
        fetchRandomGifUrl(tag).catch(() => null)
      );
      const urls = await Promise.all(tasks);
      for (const u of urls) {
        if (u) pushCache(u);
      }
      if (!cache.length) setFallbackSolid();
    }

    function pushCache(url) {
      cache.push(url);
      if (cache.length > CACHE_MAX) cache.shift();
    }

    async function fetchAndCache(tag) {
      try {
        const url = await fetchRandomGifUrl(tag);
        // Preload the image so swaps are seamless
        await new Promise((resolve, reject) => {
          const img = new Image();
          img.onload = resolve;
          img.onerror = reject;
          img.src = url;
        });
        pushCache(url);
      } catch {
        // ignore single fetch failures
      }
    }

    // --------------- Crossfade ----------------
    function nextUrl() {
      if (!cache.length) return null;
      idx = (idx + 1) % cache.length;
      return cache[idx];
    }

    function swapBackground() {
      const next = nextUrl();
      if (!next) return;

      const show = activeId === "bgA" ? elB : elA;
      const hide = activeId === "bgA" ? elA : elB;

      show.src = next;
      // Force reflow so the opacity transition triggers consistently
      // eslint-disable-next-line no-unused-expressions
      show.offsetHeight;

      hide.classList.remove("active");
      show.classList.add("active");
      activeId = activeId === "bgA" ? "bgB" : "bgA";

      // Keep the pipeline warm
      fetchAndCache(theme);
    }

    function startCycler() {
      stopCycler();
      timer = setInterval(swapBackground, SWAP_MS);
    }
    function stopCycler() {
      if (timer) { clearInterval(timer); timer = null; }
    }

    // --------------- Fireworks ----------------
    function randBetween(min, max) {
      return Math.random() * (max - min) + min;
    }
    function randColor() {
      const colors = ["#FF4136","#FF851B","#FFDC00","#01FF70","#0074D9","#B10DC9"];
      return colors[(Math.random() * colors.length) | 0];
    }
    function fireworks(x, y) {
      const count = Math.round(getComputedStyle(document.documentElement)
        .getPropertyValue("--fw-count")) || 70;

      const lifespan = 700; // ms
      const start = performance.now();

      const particles = Array.from({ length: count }, () => {
        const el = document.createElement("div");
        el.className = "particle";
        el.style.background = randColor();
        el.style.left = x + "px";
        el.style.top = y + "px";
        document.body.appendChild(el);
        return {
          el,
          angle: Math.random() * Math.PI * 2,
          speed: randBetween(50, 140),
          drag: randBetween(0.88, 0.95)
        };
      });

      function frame(t) {
        const dt = t - start;
        const p = Math.min(1, dt / lifespan);
        for (const pt of particles) {
          // simple ballistic-ish motion
          const s = pt.speed * Math.pow(pt.drag, dt / 16);
          const dx = Math.cos(pt.angle) * s * (dt / 1000);
          const dy = Math.sin(pt.angle) * s * (dt / 1000) + 0.3 * (dt / 16); // gravity
          pt.el.style.transform = `translate(${dx}px, ${dy}px)`;
          pt.el.style.opacity = String(1 - p);
        }
        if (p < 1) {
          requestAnimationFrame(frame);
        } else {
          for (const pt of particles) pt.el.remove();
        }
      }
      requestAnimationFrame(frame);
    }

    // One unified pointer handler (mouse + touch)
    let clickCount = 0;
    window.addEventListener("pointerdown", (e) => {
      fireworks(e.clientX, e.clientY);
      clickCount++;
      if (clickCount === 10) {
        // Opens your LinkedIn. Full URL as requested.
        window.open("https://www.linkedin.com/in/johannesschildt", "_blank");
        clickCount = 0;
      }
    }, { passive: true });

    // Pause when hidden to save network and battery
    document.addEventListener("visibilitychange", () => {
      if (document.hidden) stopCycler();
      else startCycler();
    });

    // --------------- Boot ---------------------
    (async function boot() {
      setFavicon(emoji);
      await preloadInitial(theme);

      // Set first visible image if available
      if (cache.length) {
        const first = cache[0];
        elA.src = first;
        elA.classList.add("active");
      }

      // Warm the cache further in the background
      for (let i = 0; i < 3; i++) fetchAndCache(theme);

      startCycler();
    })();
  </script>
</body>
</html>
